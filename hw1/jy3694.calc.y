%{
#include <iostream>
#include <math.h>
#include <stdio.h>

#include <string>
int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "ERROR: Undefined symbol" << std::endl; };
// Convert GBP to USD	 
double gbp_to_usd(double gbp)   { return gbp * 1.57; }
// Convert GBP to EURO
double gbp_to_euro(double gbp)  { return gbp * 1.26; }

// Convert USD to GBP
double usd_to_gbp(double usd)   { return usd * 0.64; }
// Convert USD to EURO
double usd_to_euro(double usd)  { return usd * 0.80; }

// Convert EURO to GBP
double euro_to_gbp(double euro) { return euro * 0.79; }
// Convert EURO to USD
double euro_to_usd(double euro) { return euro * 1.24; }

// Convert celsius to fahrenheit
double cel_to_fah(double cel) 	{ return cel * 9 / 5 + 32; }
// Convert fahrenheit to celsius
double fah_to_cel(double fah) 	{ return (fah - 32) * 5 / 9; }

// Convert kilometers to miles
double km_to_m(double km) 		  { return km * 0.62137; }
// Convert miles to kilometers 
double m_to_km(double m)  		  { return m / 0.62137;} 

// Calculate factorial
double factorial(double n) 
{
	double x; double f=1;
	
	for (x=1; x<=n; x++) { 
		f *= x; 
	}
	
	return f;
}

// Calculate modulus
int modulo(double x, double y) 
{
	return (int)x % (int)y;
}

%}

%union {
    double val;
    /* You may include additional fields as you want. */
    /* char op; */
};

%start program_input
%token EOL PI ADD SUB MUL DIV FACTORIAL POW MOD
%token SQRT ABS FLOOR CEIL COS SIN TAN LOG2 LOG10 
%token L_BRACKET R_BRACKET 
%token GBP_TO_USD USD_TO_GBP GBP_TO_EURO EURO_TO_GBP USD_TO_EURO EURO_TO_USD
%token CEL_TO_FAH FAH_TO_CEL
%token MI_TO_KM KM_TO_MI
%token VAR_KEYWORD VARIABLE EQUALS
%token <val> NUMBER    /* 'val' is the (only) field declared in %union
%token <char>                        which represents the type of the token. */
%type <val> expr function log_function trig_function conversion program_input calculation
%type <val> temp_conversion dist_conversion constant low_priority_expr assignment 
%type <string> VARIABLE
%%
program_input : line	
							| program_input line 
							;
              
line : EOL 
		 | calculation EOL 
		 ;

calculation : low_priority_expr        { std::cout << $1 << std::endl; }
						| assignment
						;

constant : PI 		{$$ = M_PI; }
				 ;

low_priority_expr : low_priority_expr ADD expr		{ $$ = $1 + $3;}
                  | low_priority_expr SUB expr		{ $$ = $1 - $3;}
                  | expr
                  ;

expr : SUB expr		{$$ = -1 * $2;}
     | function
     | constant
     | NUMBER
		 | expr DIV expr		{ $$ = $1 / $3;}
		 | expr MUL expr		{ $$ = $1 * $3;}
		 | expr POW expr		{ $$ = pow($1, $3);}
		 | expr MOD expr		{ $$ = modulo($1, $3);}
		 | L_BRACKET expr R_BRACKET { $$ = $2; }
		 ;

function : conversion
         | log_function
         | trig_function
				 | expr FACTORIAL { $$ = factorial($1); }
				 | SQRT expr			{ $$ = sqrt($2); }
				 | ABS expr				{ $$ = $2 >= 0? $2 : - $2; }
				 | FLOOR expr			{ $$ = floor($2); }
				 | CEIL expr 			{ $$ = ceil($2); }
				 ;

trig_function : COS expr	{ $$ = cos($2); }
							| SIN expr	{ $$ = sin($2); }
							| TAN expr  { $$ = tan($2); }
							;

log_function : LOG2 expr  { $$ = log2($2); }
						 | LOG10 expr { $$ = log10($2); }
						 ;

conversion : temp_conversion
					 | dist_conversion
					 | expr GBP_TO_USD { $$ = gbp_to_usd($1); }
					 | expr USD_TO_GBP { $$ = usd_to_gbp($1); }
					 | expr GBP_TO_EURO { $$ = gbp_to_euro($1); }
					 | expr EURO_TO_GBP { $$ = euro_to_gbp($1); }
					 | expr USD_TO_EURO { $$ = usd_to_euro($1); }
					 | expr EURO_TO_USD { $$ = euro_to_usd($1); }
					 ;

temp_conversion : expr CEL_TO_FAH		{ $$ = cel_to_fah($1); }
								| expr FAH_TO_CEL		{ $$ = fah_to_cel($1); }
								;

dist_conversion : expr MI_TO_KM			{ $$ = m_to_km($1); }
								| expr KM_TO_MI			{ $$ = km_to_m($1); }
								;


//assignment : VAR_KEYWORD VARIABLE EQUALS calculation { $2->value.var = $4; }
assignment : VAR_KEYWORD VARIABLE EQUALS calculation { $$ = $4; }
					 ;
%%

int main()
{ 
	yyparse(); // A parsing function that will be generated by Bison.
	return 0;
  
}
